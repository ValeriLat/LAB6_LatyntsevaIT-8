# Латынцева Валерия ИТ-8 8 вариант ЛАБ 6

ЗАДАНИЕ 1
@Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные
аннотацией @Invoke, и вызывает их автоматически.

АЛГОРИТМ
Создать аннотацию @Invoke

Цель: ElementType.METHOD
Доступ: RetentionPolicy.RUNTIME
Без свойств
Создать класс с методами

Добавить несколько обычных методов
Пометить минимум 2 метода аннотацией @Invoke
Создать обработчик InvokeHandler

Получить класс объекта через getClass()
Получить все методы через getDeclaredMethods()
Для каждого метода:

Проверить наличие аннотации @Invoke
Если есть - вызвать метод через method.invoke(obj)
Вывести информацию о выполненных методах

ТЕСТ
1. Тест @Invoke:
Еще один автоматический метод
Выполнен метод: anotherAutoMethod
Автоматический вызов метода! Count: 1
Выполнен метод: executeAutomatically
Всего выполнено методов: 2

ЗАДАНИЕ 2
@Default.
Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.

АЛГОРИТМ
Создать аннотацию @Default

Цель: ElementType.TYPE и ElementType.FIELD
Доступ: RetentionPolicy.RUNTIME
Обязательное свойство: Class<?> value()
Создать класс с аннотацией

Пометить класс аннотацией @Default(SomeClass.class)
Пометить поле аннотацией @Default(AnotherClass.class)
Создать обработчик DefaultHandler

Получить класс для анализа
Проверить наличие аннотации @Default
Если есть - извлечь значение value()
Вывести имя класса по умолчанию

ТЕСТ
2. Тест @Default:
Указанный класс по умолчанию: java.lang.Integer

ЗАДАНИЕ 3
@ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES.

АЛГОРИТМ
Создать аннотацию @ToString

Цель: ElementType.TYPE и ElementType.FIELD
Доступ: RetentionPolicy.RUNTIME
Свойство: Mode value() с значениями YES/NO
Значение по умолчанию: YES
Создать класс UserProfile с полями

Пометить класс @ToString
Некоторые поля пометить @ToString(Mode.YES)
Некоторые поля пометить @ToString(Mode.NO)
Создать обработчик ToStringHandler

Получить класс объекта
Проверить аннотацию на классе
Получить все поля через getDeclaredFields()
Для каждого поля:

Проверить аннотацию @ToString
Если Mode.YES или нет аннотации - включить в результат
Если Mode.NO - пропустить поле
Сформировать строковое представление

ТЕСТ
3. Тест @ToString:
Результат: UserProfile{username=Alice, loginCount=10}

ЗАДАНИЕ 4
@Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.

АЛГОРИТМ
Создать аннотацию @Validate

Цель: ElementType.TYPE и ElementType.ANNOTATION_TYPE
Доступ: RetentionPolicy.RUNTIME
Обязательное свойство: Class<?>[] value()
Создать класс ValidationContainer

Пометить аннотацией @Validate({Class1.class, Class2.class})
Создать обработчик ValidateHandler

Получить класс для анализа
Проверить наличие аннотации @Validate
Извлечь массив классов из value()
Вывести список классов для валидации

ТЕСТ
4. Тест @Validate:
Список классов для валидации:
  • Double
  • Boolean
  • Float
Всего классов: 3

ЗАДАНИЕ 5
@Two.
Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.

АЛГОРИТМ
Создать аннотацию @Two

Цель: ElementType.TYPE
Доступ: RetentionPolicy.RUNTIME
Обязательные свойства:

String first()
int second()
Создать класс DoubleValueClass

Пометить аннотацией @Two(first = "текст", second = 123)
Создать обработчик TwoHandler

Получить класс для анализа
Проверить наличие аннотации @Two
Извлечь значения first() и second()
Вывести оба значения
Проверить корректность (строка не пустая, число ≥ 0)

ТЕСТ
5. Тест @Two:
Параметры аннотации @Two:
  Текст: 'Тестовые данные'
  Число: 100

ЗАДАНИЕ 6
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.

АЛГОРИТМ
Создать аннотацию @Cache

Цель: ElementType.TYPE
Доступ: RetentionPolicy.RUNTIME
Свойство: String[] value() с пустым массивом по умолчанию
Создать класс CacheStorage

Пометить аннотацией @Cache({"область1", "область2"})
Создать обработчик CacheHandler

Получить класс для анализа
Проверить наличие аннотации @Cache
Извлечь массив строк из value()
Если массив пустой - вывести сообщение
Иначе вывести список областей кеширования

ТЕСТ
6. Тест @Cache:
Конфигурация кеша:
  Области кеширования:
    1. session
    2. preferences
    3. settings

ЗАДАНИЕ 2.2
Создайте тест, используя фреймворк JUnit, который проверяет корректность вызова методов,
отмеченных аннотацией @Invoke.
• Использовать Reflection API для поиска методов с аннотацией.
• Убедиться, что метод действительно выполняется без исключений.
• Проверить, что возвращаемое значение или побочный эффект соответствует ожиданиям
(например, устанавливает флаг или изменяет состояние объекта).
• Тест должен использовать аннотацию @BeforeEach для подготовки тестируемого
экземпляра класса.

АЛГОРИТМ
Подготовка теста

Создать поле MethodInvoker methodInvoker
В @BeforeEach инициализировать объект
Тест поиска методов

Получить методы через Reflection
Проверить что найдены методы с @Invoke
Тест выполнения методов

Вызвать InvokeHandler.executeAnnotatedMethods()
Проверить что методы выполняются без исключений
Тест побочного эффекта

Запомнить начальное состояние
Выполнить аннотированные методы
Проверить изменение состояния объекта

ТЕСТ
Тест @Invoke (2.2)
Еще один автоматический метод
Выполнен метод: anotherAutoMethod
Автоматический вызов метода! Count: 1
Выполнен метод: executeAutomatically
Всего выполнено методов: 2
@Invoke тест пройден

ЗАДАНИЕ 2.3
Разработайте тест, используя фреймворк JUnit, который проверяет корректность обработки
аннотации @Default.
• Проверить, что значение свойства value совпадает с ожидаемым классом.
• Убедиться, что если аннотация установлена на класс или поле, то отражение (Reflection)
корректно возвращает её экземпляр.
• Добавить параметризованный тест (@ParameterizedTest) для проверки нескольких
классов с разными типами по умолчанию.

АЛГОРИТМ
ест значения аннотации

Получить аннотацию @Default с класса
Проверить что defaultClass() равен ожидаемому
Тест Reflection

Проверить что аннотация возвращается с класса
Проверить что аннотация возвращается с поля
Параметризованный тест

Создать тест с @ParameterizedTest
Передать разные классы через @ValueSource
Проверить работу с разными типами

ТЕСТ
Тест @Default (2.3)
Указанный класс по умолчанию: java.lang.Integer
@Default тест пройден
Все тесты прошли успешно!
